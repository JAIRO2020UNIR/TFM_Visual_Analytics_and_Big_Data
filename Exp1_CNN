# MODELO CNN PARA DETECCIÓN DE CÁNCER DE MAMA
# Basado en imágenes ecográficas del dataset BUSI

# 1. Importación de librerías
import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import (
    classification_report, confusion_matrix, roc_curve, auc
)
import seaborn as sns
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import (
    Conv2D, MaxPooling2D, Flatten, Dense, Dropout, BatchNormalization
)
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.callbacks import EarlyStopping

# 2. Ruta base del dataset
dataset_path = "/content/drive/MyDrive/Dataset_BUSI_with_GT"

# 3. Definición de clases y etiquetas
categories = ['normal', 'benign', 'malignant']
label_dict = {'normal': 0, 'benign': 1, 'malignant': 2}

# 4. Parámetros de procesamiento
IMG_SIZE = 128
MAX_PER_CLASS = 150

images = []
labels = []
class_counts = {0: 0, 1: 0, 2: 0}

# 5. Cargar imágenes y asignar etiquetas
for category in categories:
    folder_path = os.path.join(dataset_path, category)
    class_label = label_dict[category]

    for file in os.listdir(folder_path):
        if "_mask" in file.lower():
            continue
        if class_counts[class_label] >= MAX_PER_CLASS:
            continue

        img_path = os.path.join(folder_path, file)
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)

        if img is not None:
            img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))
            images.append(img)
            labels.append(class_label)
            class_counts[class_label] += 1

# 6. Preparación de datos
X = np.array(images) / 255.0
X = X.reshape(-1, IMG_SIZE, IMG_SIZE, 1)
y = to_categorical(labels, num_classes=3)

# 7. División en entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

# 8. Definición del modelo CNN
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 1)),
    MaxPooling2D((2, 2)),
    BatchNormalization(),
    Dropout(0.3),

    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    BatchNormalization(),
    Dropout(0.3),

    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    BatchNormalization(),
    Dropout(0.4),

    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.5),
    Dense(3, activation='softmax')
])

# 9. Compilación del modelo
model.compile(optimizer=Adam(learning_rate=0.001),
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# 10. Entrenamiento con EarlyStopping
early_stop = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

history = model.fit(
    X_train, y_train,
    epochs=30,
    batch_size=25,
    validation_split=0.2,
    callbacks=[early_stop],
    verbose=1
)

# 11. Evaluación del modelo
test_loss, test_acc = model.evaluate(X_test, y_test)
print(f"\n Exactitud (accuracy) en prueba: {test_acc:.4f}")

# 12. Predicciones
y_pred = model.predict(X_test)
y_pred_classes = np.argmax(y_pred, axis=1)
y_true = np.argmax(y_test, axis=1)

# 13. Métricas detalladas
print("\n===== REPORTE DE CLASIFICACIÓN =====")
print(classification_report(y_true, y_pred_classes, target_names=categories))

# 14. Matriz de Confusión
cm = confusion_matrix(y_true, y_pred_classes)
plt.figure(figsize=(6,5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=categories, yticklabels=categories)
plt.xlabel("Predicción")
plt.ylabel("Real")
plt.title("Matriz de Confusión - CNN")
plt.show()

# 15. Curva ROC y AUC
y_prob = y_pred
fpr = {}
tpr = {}
roc_auc = {}

for i in range(3):
    fpr[i], tpr[i], _ = roc_curve(y_test[:, i], y_prob[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

plt.figure(figsize=(7,6))
for i, color in zip(range(3), ['blue', 'green', 'red']):
    plt.plot(fpr[i], tpr[i], color=color, lw=2,
             label=f'{categories[i]} (AUC = {roc_auc[i]:.3f})')
plt.plot([0,1], [0,1], 'k--')
plt.xlabel('Tasa de Falsos Positivos (FPR)')
plt.ylabel('Tasa de Verdaderos Positivos (TPR)')
plt.title('Curvas ROC por Clase - CNN')
plt.legend()
plt.show()

# 16. Gráfica de pérdida y precisión
plt.figure(figsize=(12,5))
plt.subplot(1,2,1)
plt.plot(history.history['accuracy'], label='Entrenamiento')
plt.plot(history.history['val_accuracy'], label='Validación')
plt.title('Evolución de la Exactitud')
plt.xlabel('Épocas')
plt.ylabel('Exactitud')
plt.legend()

plt.subplot(1,2,2)
plt.plot(history.history['loss'], label='Entrenamiento')
plt.plot(history.history['val_loss'], label='Validación')
plt.title('Evolución de la Pérdida')
plt.xlabel('Épocas')
plt.ylabel('Pérdida')
plt.legend()
plt.show()

# 17. Guardar el modelo entrenado
model.save("modelo_cnn_cancer_mama.h5")
print("\n Modelo guardado como 'modelo_cnn_cancer_mama.h5'")
